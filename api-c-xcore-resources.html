
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C XCore Resources &mdash; Documentation  documentation</title>
    <link rel="stylesheet" href="_static/xdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/xcomment.js"></script>
    <link rel="top" title="Documentation  documentation" href="index.html" />
    <link rel="prev" title="Documentation" href="index.html" /> 

<script>
function setheight() {
h1 = document.getElementById('d1').style.height;
h2 = document.getElementById('d2').style.height;

if (parseInt(h1) > parseInt(h2)) {
document.getElementById('d2').style.height=h1 + "px";
}
else {
document.getElementById('d1').style.height=h2 + "px";
}

}
</script>
</head>

<body onload="setheight();">

  

    <div class="document" id='d1'>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
<div style="float: right">
<a href="index.html"
                        title="previous chapter"> &lt&lt </a>
</div>

            
  <div class="section" id="c-xcore-resources">
<h1>C XCore Resources<a class="headerlink" href="#c-xcore-resources" title="Permalink to this headline">¶</a></h1>
<p>The module c_xcore_resources is intended to provide low level access to all
XCore features from C. This library is intended to ease porting of legacy
software. Note that since C is not resource aware, the compiler cannot
analyse and optimise resource access to the same depth as the XC compiler.</p>
<div class="section" id="timers">
<h2>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h2>
<p>To use xcore timers from C, include the file <tt class="docutils literal"><span class="pre">timer.h</span></tt>.</p>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="timer_t">
<tt class="descname">timer_t</tt><a class="headerlink" href="#timer_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Type that denotes a timer.</p>
<p>Variables of this type should be initalised using <a class="reference internal" href="#timer_init" title="timer_init"><span>timer_init()</span></a>, and deinitialised using <a class="reference internal" href="#timer_exit" title="timer_exit"><span>timer_exit()</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="api">
<h3>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="timer_init">
void <tt class="descname">timer_init</tt><big>(</big><a class="reference internal" href="#timer_t" title="timer_t"><span>timer_t</span></a><em>&nbsp;t</em><big>)</big><a class="headerlink" href="#timer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that allocates and initialises a timer.</p>
<p>This macro is to be called once on every variable of the type <tt class="docutils literal"><span class="pre">timer_t</span></tt>. If there are no timers availble, then <tt class="docutils literal"><span class="pre">t</span></tt> will be set to NULL. When the timer is no longer required, <a class="reference internal" href="#timer_exit" title="timer_exit"><span>timer_exit()</span></a> should be called to free the timer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> &#8211; timer to be initialised</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="timer_exit">
void <tt class="descname">timer_exit</tt><big>(</big><a class="reference internal" href="#timer_t" title="timer_t"><span>timer_t</span></a><em>&nbsp;t</em><big>)</big><a class="headerlink" href="#timer_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that deallocates and initialises a timer.</p>
<p>This macro is to be called once on every variable of the type <tt class="docutils literal"><span class="pre">timer_t</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> &#8211; timer to be freed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="timer_in">
void <tt class="descname">timer_in</tt><big>(</big><a class="reference internal" href="#timer_t" title="timer_t"><span>timer_t</span></a><em>&nbsp;t</em>, int<em>&nbsp;time</em><big>)</big><a class="headerlink" href="#timer_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs the current time from the timer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> &#8211; timer on which to input</li>
<li><strong>time</strong> &#8211; variable in which to leave the 32-bit time.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="timer_in_when_timerafter">
void <tt class="descname">timer_in_when_timerafter</tt><big>(</big><a class="reference internal" href="#timer_t" title="timer_t"><span>timer_t</span></a><em>&nbsp;t</em>, int<em>&nbsp;time</em>, int<em>&nbsp;after_time</em><big>)</big><a class="headerlink" href="#timer_in_when_timerafter" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs the current time from the timer, but only after a specified time has been reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> &#8211; timer on which to input</li>
<li><strong>time</strong> &#8211; variable in which to leave the 32-bit time.</li>
<li><strong>after_time</strong> &#8211; time for which to wait</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Example code that uses timers is shown below. A timer is declared, and
initialised. After that, the timer value is input, whereupon the code waits
for 100 reference clock ticks.</p>
<div class="highlight-none"><div class="highlight"><pre>void timertest() {
    timer_t tmr;
    int v;

    timer_init(tmr);
    timer_in(tmr, v);           // input current time value
    v += 100;      // add 100 = 1us as ref clock is 100 MHz
    timer_in_when_timerafter(tmr, v, v);  // wait for v+100
    timer_exit(tmr);
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="channels">
<h2>Channels<a class="headerlink" href="#channels" title="Permalink to this headline">¶</a></h2>
<p>There are two types of channels: streaming channels and normal channels.
The latter are safe and synchronised; the former are not sychronised and
keep a route through the switches open.</p>
<p>To use xcore channels from C, include the file <tt class="docutils literal"><span class="pre">chan.h</span></tt>.</p>
<div class="section" id="id1">
<h3>Types<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="chanend_t">
<tt class="descname">chanend_t</tt><a class="headerlink" href="#chanend_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Type that denotes a channel-end.</p>
<p>Communication channels comprise two connected channel-ends and can be created using <a class="reference internal" href="#chan_init" title="chan_init"><span>chan_init()</span></a>. Channels should be deinitialised using <a class="reference internal" href="#chan_exit" title="chan_exit"><span>chan_exit()</span></a>.</p>
</dd></dl>

<dl class="type">
<dt id="streaming_chanend_t">
<tt class="descname">streaming_chanend_t</tt><a class="headerlink" href="#streaming_chanend_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Type that denotes a stremaing channel-end.</p>
<p>Streaming communication channels comprise two connected streaming channel-ends and can be created using <a class="reference internal" href="#schan_init" title="schan_init"><span>schan_init()</span></a>. Streaming channels should be deinitialised using <a class="reference internal" href="#schan_exit" title="schan_exit"><span>schan_exit()</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h3>API<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="chan_init">
void <tt class="descname">chan_init</tt><big>(</big><a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c1</em>, <a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c2</em><big>)</big><a class="headerlink" href="#chan_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that creates a channel between a pair of channel-ends.</p>
<p>The channel-end variables must reside on the same core.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c1</strong> &#8211; channel-end of one side</li>
<li><strong>c2</strong> &#8211; channel-end of the other side</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chan_exit">
void <tt class="descname">chan_exit</tt><big>(</big><a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c1</em>, <a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c2</em><big>)</big><a class="headerlink" href="#chan_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that disconnects and deallocates a channel between a pair of channel-ends.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c1</strong> &#8211; channel-end of one side</li>
<li><strong>c2</strong> &#8211; channel-end of the other side</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chan_out_int">
void <tt class="descname">chan_out_int</tt><big>(</big><a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#chan_out_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that outputs an integer over a channel-end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the channel-end.</li>
<li><strong>data</strong> &#8211; the integer to be output.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="chan_in_int">
void <tt class="descname">chan_in_int</tt><big>(</big><a class="reference internal" href="#chanend_t" title="chanend_t"><span>chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#chan_in_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs an integer from a channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the channel-end.</li>
<li><strong>data</strong> &#8211; variable in which to write the inputted integer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_init">
void <tt class="descname">schan_init</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c1</em>, <a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c2</em><big>)</big><a class="headerlink" href="#schan_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that creates a streaming channel between a pair of streaming channel-ends.</p>
<p>The channel-end variables must reside on the same core.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c1</strong> &#8211; channel-end of one side</li>
<li><strong>c2</strong> &#8211; channel-end of the other side</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_exit">
void <tt class="descname">schan_exit</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c1</em>, <a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c2</em><big>)</big><a class="headerlink" href="#schan_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that disconnects and deallocates a streaming channel between a pair of streaming channel-ends.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c1</strong> &#8211; channel-end of one side</li>
<li><strong>c2</strong> &#8211; channel-end of the other side</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_outct">
void <tt class="descname">schan_outct</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;ct</em><big>)</big><a class="headerlink" href="#schan_outct" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that outputs a control token onto a streaming channel-end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the streaming channel-end.</li>
<li><strong>ct</strong> &#8211; control token to be output. Legal control tokens that can be used are 0 or any value in the range 3..191 inclusive.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_chkct">
void <tt class="descname">schan_chkct</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;ct</em><big>)</big><a class="headerlink" href="#schan_chkct" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that checks that a specific control token is available on a streaming channel-end.</p>
<p>This macro blocks until a token is available on th e streaming channel. If the available token is a control token and has the value <tt class="docutils literal"><span class="pre">ct</span></tt>, then the token is input and discarded. Otherwise an exception is raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the streaming channel-end.</li>
<li><strong>ct</strong> &#8211; control token that is expected on the streaming channel. If a different token arrives.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_out_int">
void <tt class="descname">schan_out_int</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#schan_out_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that outputs an integer over a streaming channel-end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the streaming channel-end.</li>
<li><strong>data</strong> &#8211; the integer to be output.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="schan_in_int">
void <tt class="descname">schan_in_int</tt><big>(</big><a class="reference internal" href="#streaming_chanend_t" title="streaming_chanend_t"><span>streaming_chanend_t</span></a><em>&nbsp;c</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#schan_in_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs an integer from a streaming channel-end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c</strong> &#8211; the streaming channel-end.</li>
<li><strong>data</strong> &#8211; variable in which to write the inputted integer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>Example<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>An example program is shown in <a class="reference internal" href="#sec-api-threads"><span>Example thread usage</span></a>.</p>
</div>
</div>
<div class="section" id="ports">
<h2>Ports<a class="headerlink" href="#ports" title="Permalink to this headline">¶</a></h2>
<p>To use xcore ports from C, include the file <tt class="docutils literal"><span class="pre">port.h</span></tt>.</p>
<div class="section" id="id4">
<h3>Types<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="port_t">
<tt class="descname">port_t</tt><a class="headerlink" href="#port_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Type that denotes a port.</p>
<p>Variables of this type should be initalised using <a class="reference internal" href="#port_init" title="port_init"><span>port_init()</span></a> or <a class="reference internal" href="#port_init_buffered" title="port_init_buffered"><span>port_init_buffered()</span></a>, and deinitialised using <a class="reference internal" href="#port_exit" title="port_exit"><span>port_exit()</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="id5">
<h3>API<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="port_init">
void <tt class="descname">port_init</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;port</em><big>)</big><a class="headerlink" href="#port_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that initialises a port variable to a specific port.</p>
<p>The port should be one of XS1_PORT_1A .. XS1_PORT_32A as specified on the datasheet and in the xs1.h include file. Either this function or <a class="reference internal" href="#port_init_buffered" title="port_init_buffered"><span>port_init_buffered()</span></a> should be called once for each variable of type <tt class="docutils literal"><span class="pre">port_t</span></tt>; <a class="reference internal" href="#port_exit" title="port_exit"><span>port_exit()</span></a> should be called afterwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable to initialise</li>
<li><strong>port</strong> &#8211; value that identifies which port to drive.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_init_buffered">
void <tt class="descname">port_init_buffered</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;port</em>, int<em>&nbsp;shift_width</em><big>)</big><a class="headerlink" href="#port_init_buffered" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that initialises a port variable to a specific port, and enables teh port to buffer and serialise/deserialise data.</p>
<p>The port should be one of XS1_PORT_1A .. XS1_PORT_32A as specified on the datasheet and in the xs1.h include file. Either this function or <a class="reference internal" href="#port_init" title="port_init"><span>port_init()</span></a> should be called once for each variable of type <tt class="docutils literal"><span class="pre">port_t</span></tt>; <a class="reference internal" href="#port_exit" title="port_exit"><span>port_exit()</span></a> should be called afterwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable to initialise</li>
<li><strong>port</strong> &#8211; value that identifies which port to drive.</li>
<li><strong>shift_width</strong> &#8211; number of bits to serialise; must be 1, 2, 4, 8, or 32</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_exit">
void <tt class="descname">port_exit</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em><big>)</big><a class="headerlink" href="#port_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that uninitialises a port variable.</p>
<p>This function switches off the port.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable to initialise</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_out">
void <tt class="descname">port_out</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#port_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that outputs a value onto a port.</p>
<p>In the case of an unbuffered port, the value will be driven on the pins on the next clock cycle. In the case of a buffered port, the data will be stored in the buffer, and be serialised onto the output pins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable that inidicates which port to output to</li>
<li><strong>data</strong> &#8211; value to output</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_in">
void <tt class="descname">port_in</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;data</em><big>)</big><a class="headerlink" href="#port_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs a value from a port.</p>
<p>In the case of an unbuffered port, the data will be whatever is on the input pins. In the case of a buffered port, this macro will wait until the buffer is filled up with deserialised data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable that inidicates which port to input from</li>
<li><strong>data</strong> &#8211; variable to input into</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_in_when_pinseq">
void <tt class="descname">port_in_when_pinseq</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;data</em>, int<em>&nbsp;value</em><big>)</big><a class="headerlink" href="#port_in_when_pinseq" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs a value from a port conditionally; when the pins match a specific value.</p>
<p>In the case of an unbuffered port, the data will be identical to the value. In the case of a buffered port, this macro will wait until the value appears on the pins, and then return that value and previous values deserialised into <tt class="docutils literal"><span class="pre">data</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable that inidicates which port to input from</li>
<li><strong>data</strong> &#8211; variable to input into</li>
<li><strong>value</strong> &#8211; conditional value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="port_in_when_pinsneq">
void <tt class="descname">port_in_when_pinsneq</tt><big>(</big><a class="reference internal" href="#port_t" title="port_t"><span>port_t</span></a><em>&nbsp;p</em>, int<em>&nbsp;data</em>, int<em>&nbsp;value</em><big>)</big><a class="headerlink" href="#port_in_when_pinsneq" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro that inputs a value from a port conditionally; when the pins do not match a specific value.</p>
<p>In the case of an unbuffered port, the data will be the non-matchine pin values. In the case of a buffered port, this macro will wait until a non matching value appears on the pins, and then return that value and previous values deserialised into <tt class="docutils literal"><span class="pre">data</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; port variable that inidicates which port to input from</li>
<li><strong>data</strong> &#8211; variable to input into</li>
<li><strong>value</strong> &#8211; conditional value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id6">
<h3>Example<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Example code that uses ports is shown below. This piece of code uses two
ports, <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt>. Each of the ports is initialised: <tt class="docutils literal"><span class="pre">x</span></tt> is
initialised as <tt class="docutils literal"><span class="pre">PORT_1A</span> <span class="pre">(pin</span> <span class="pre">X0D0</span> <span class="pre">on</span> <span class="pre">an</span> <span class="pre">L1,</span> <span class="pre">see</span> <span class="pre">the</span> <span class="pre">datasheet);</span> <span class="pre">``y</span></tt> is
initialised as a buffered port that serialises 32 bits of data, and is on
<tt class="docutils literal"><span class="pre">PORT_1B</span></tt> (pin X0D1 on an L1). Both ports are used as output ports only,
and the sequence high, low, high is output to port <tt class="docutils literal"><span class="pre">x</span></tt> in short succession.
After that, 64 pulses are output onto port <tt class="docutils literal"><span class="pre">y</span></tt> (4 times 32 bits of data,
each 32 bits comprising a sequence <tt class="docutils literal"><span class="pre">1010101..10</span></tt>).</p>
<div class="highlight-none"><div class="highlight"><pre>void porttest() {
    port_t x, y;
    port_init(x, XS1_PORT_1A);
    port_init_buffered(y, XS1_PORT_1B, 32);
    port_out(x, 1);
    port_out(x, 0);
    port_out(x, 1);
    port_out(y, 0xAAAAAAAA);
    port_out(y, 0xAAAAAAAA);
    port_out(y, 0xAAAAAAAA);
    port_out(y, 0xAAAAAAAA);
    port_exit(x);
    port_exit(y);
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="threads">
<h2>Threads<a class="headerlink" href="#threads" title="Permalink to this headline">¶</a></h2>
<p>To use threads from C, include the file <tt class="docutils literal"><span class="pre">thread.h</span></tt>.</p>
<div class="section" id="id7">
<h3>Types<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="thread_t">
<tt class="descname">thread_t</tt><a class="headerlink" href="#thread_t" title="Permalink to this definition">¶</a></dt>
<dd><p>A type that denotes a thread created by <a class="reference internal" href="#thread_create" title="thread_create"><span>thread_create()</span></a>.</p>
<p>Use <a class="reference internal" href="#thread_join" title="thread_join"><span>thread_join()</span></a> to wait for the thread to terminate.</p>
</dd></dl>

<dl class="type">
<dt id="thread_group_t">
<tt class="descname">thread_group_t</tt><a class="headerlink" href="#thread_group_t" title="Permalink to this definition">¶</a></dt>
<dd><p>A type that denotes a group of threads.</p>
<p>Use <a class="reference internal" href="#thread_group_create" title="thread_group_create"><span>thread_group_create()</span></a> to create a new thread group and use <a class="reference internal" href="#thread_group_join" title="thread_group_join"><span>thread_group_join()</span></a> to wait until all the threads have terminated.</p>
</dd></dl>

</div>
<div class="section" id="id8">
<h3>API<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="thread_create">
int <tt class="descname">thread_create</tt><big>(</big><a class="reference internal" href="#thread_t" title="thread_t"><span>thread_t</span></a><em>&nbsp;*t</em>, void *(*start_routine)(void<em>&nbsp;*)</em>, void<em>&nbsp;*stack</em>, unsigned<em>&nbsp;stackspace</em>, void<em>&nbsp;*arg</em><big>)</big><a class="headerlink" href="#thread_create" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_create" title="thread_create"><span>thread_create()</span></a> allocates and starts a new thread.</p>
<p>The thread executes <span class="tt"><span>start_routine</span></span> with <span class="tt"><span>arg</span></span> as its only argument. If <span class="tt"><span>start_routine</span></span> returns the effect is as if there was a call to <a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> using the return value of <span class="tt"><span>start_routine</span></span> as the exit value.</p>
<p>The calling thread must call <a class="reference internal" href="#thread_join" title="thread_join"><span>thread_join()</span></a> to reclaim the resources used to create the thread.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> &#8211; On successful creation of the thread the ID of the thread&#8217;s synchronizer is stored to this argument.</li>
<li><strong>start_routine</strong> &#8211; The function to execute on the thread.</li>
<li><strong>stack</strong> &#8211; Pointer to a block of memory that is used for the new thread&#8217;s stack.</li>
<li><strong>stackspace</strong> &#8211; Size of the <span class="tt"><span>stack</span></span> argument in words.</li>
<li><strong>arg</strong> &#8211; The argument to pass to <span class="tt"><span>start_routine</span></span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, non zero on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_create_detached">
int <tt class="descname">thread_create_detached</tt><big>(</big>void *(*start_routine)(void<em>&nbsp;*)</em>, void<em>&nbsp;*stack</em>, unsigned<em>&nbsp;stackspace</em>, void<em>&nbsp;*arg</em><big>)</big><a class="headerlink" href="#thread_create_detached" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_create_detached" title="thread_create_detached"><span>thread_create_detached()</span></a> allocates and starts a new thread.</p>
<p>The thread executes <span class="tt"><span>start_routine</span></span> with <span class="tt"><span>arg</span></span> as its only argument. If <span class="tt"><span>start_routine</span></span> returns the effect is as if there was a call to <a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> using the return value of <span class="tt"><span>start_routine</span></span> as the exit value.</p>
<p>Unlike <a class="reference internal" href="#thread_create" title="thread_create"><span>thread_create()</span></a> the resources used to create the thread as reclaimed as soon as the thread terminates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start_routine</strong> &#8211; The function to execute on the thread.</li>
<li><strong>stack</strong> &#8211; Pointer to a block of memory that is used for the new thread&#8217;s stack.</li>
<li><strong>stackspace</strong> &#8211; Size of the <span class="tt"><span>stack</span></span> argument in words.</li>
<li><strong>arg</strong> &#8211; The argument to pass to <span class="tt"><span>start_routine</span></span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, non zero on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_join">
void* <tt class="descname">thread_join</tt><big>(</big><a class="reference internal" href="#thread_t" title="thread_t"><span>thread_t</span></a><em>&nbsp;thread</em><big>)</big><a class="headerlink" href="#thread_join" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_join" title="thread_join"><span>thread_join()</span></a> pauses execution of the calling thread until the thread specified as an argument terminates.</p>
<p>The behaviour is undefined if <a class="reference internal" href="#thread_join" title="thread_join"><span>thread_join()</span></a> is called multiple times with the same thread.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thread</strong> &#8211; The synchronizer of the thread to wait for.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The exit value passed to <a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> by the terminating thread.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_exit">
void <tt class="descname">thread_exit</tt><big>(</big>void *value)<em>&nbsp;__attribute__((noreturn)</em><big>)</big><a class="headerlink" href="#thread_exit" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> terminates execution of the calling thread.</p>
<p>If the thread was created using <a class="reference internal" href="#thread_create" title="thread_create"><span>thread_create()</span></a> the exit value is made available to a thread calling <a class="reference internal" href="#thread_join" title="thread_join"><span>thread_join()</span></a>.</p>
<p>The behaviour is undefined is <a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> is called from a thread which was not started by <a class="reference internal" href="#thread_create" title="thread_create"><span>thread_create()</span></a>, <a class="reference internal" href="#thread_create_detached" title="thread_create_detached"><span>thread_create_detached()</span></a> or <a class="reference internal" href="#thread_create_in_group" title="thread_create_in_group"><span>thread_create_in_group()</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="thread_group_create">
int <tt class="descname">thread_group_create</tt><big>(</big><a class="reference internal" href="#thread_group_t" title="thread_group_t"><span>thread_group_t</span></a><em>&nbsp;*group</em><big>)</big><a class="headerlink" href="#thread_group_create" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_group_create" title="thread_group_create"><span>thread_group_create()</span></a> allocates a new thread group.</p>
<p>Thread groups support efficient barrier synchronization via the <a class="reference internal" href="#thread_sync" title="thread_sync"><span>thread_sync()</span></a> and <a class="reference internal" href="#thread_group_sync" title="thread_group_sync"><span>thread_group_sync()</span></a> functions. Threads are added to the thread group using <a class="reference internal" href="#thread_create_in_group" title="thread_create_in_group"><span>thread_create_in_group()</span></a>. Threads in the thread group are initially paused. <a class="reference internal" href="#thread_group_start" title="thread_group_start"><span>thread_group_start()</span></a> is used to start execution of all threads in the thread group. <a class="reference internal" href="#thread_group_join" title="thread_group_join"><span>thread_group_join()</span></a> must be called to reclaim the resources used to create the thread group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>group</strong> &#8211; On successful creation of the thread group the ID of the thread group&#8217;s synchronizer is stored to this argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, non zero on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_create_in_group">
int <tt class="descname">thread_create_in_group</tt><big>(</big>void *(*start_routine)(void<em>&nbsp;*)</em>, <a class="reference internal" href="#thread_group_t" title="thread_group_t"><span>thread_group_t</span></a><em>&nbsp;group</em>, void<em>&nbsp;*stack</em>, unsigned<em>&nbsp;stackspace</em>, void<em>&nbsp;*arg</em><big>)</big><a class="headerlink" href="#thread_create_in_group" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_create_in_group" title="thread_create_in_group"><span>thread_create_in_group()</span></a> allocates a new thread and adds it to the specified thread group.</p>
<p>The thread group must not have already been started. The allocated thread is initially paused. When the thread group is started the allocated thread will call <span class="tt"><span>start_routine</span></span> with <span class="tt"><span>arg</span></span> as its only argument. If <span class="tt"><span>start_routine</span></span> returns the effect is as if there was a call to <a class="reference internal" href="#thread_exit" title="thread_exit"><span>thread_exit()</span></a> using the return value of <span class="tt"><span>start_routine</span></span> as the exit value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start_routine</strong> &#8211; The function to execute on the thread.</li>
<li><strong>group</strong> &#8211; The thread group for the thread.</li>
<li><strong>stack</strong> &#8211; Pointer to a block of memory that is used for the new thread&#8217;s stack.</li>
<li><strong>stackspace</strong> &#8211; Size of the <span class="tt"><span>stack</span></span> argument in words.</li>
<li><strong>arg</strong> &#8211; The argument to pass to <span class="tt"><span>start_routine</span></span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">0 on success, non zero on failure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_group_start">
void <tt class="descname">thread_group_start</tt><big>(</big><a class="reference internal" href="#thread_group_t" title="thread_group_t"><span>thread_group_t</span></a><em>&nbsp;group</em><big>)</big><a class="headerlink" href="#thread_group_start" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_group_start" title="thread_group_start"><span>thread_group_start()</span></a> starts all threads in the thread group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>group</strong> &#8211; The thread group to start.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_sync">
void <tt class="descname">thread_sync</tt><big>(</big>void<big>)</big><a class="headerlink" href="#thread_sync" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_sync" title="thread_sync"><span>thread_sync()</span></a> pauses execution of the current thread utill all threads in the same thread group have called <a class="reference internal" href="#thread_sync" title="thread_sync"><span>thread_sync()</span></a> and <a class="reference internal" href="#thread_group_sync" title="thread_group_sync"><span>thread_group_sync()</span></a> has been called in the parent thread.</p>
</dd></dl>

<dl class="function">
<dt id="thread_group_sync">
void <tt class="descname">thread_group_sync</tt><big>(</big><a class="reference internal" href="#thread_group_t" title="thread_group_t"><span>thread_group_t</span></a><em>&nbsp;group</em><big>)</big><a class="headerlink" href="#thread_group_sync" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#thread_group_sync" title="thread_group_sync"><span>thread_group_sync()</span></a> pauses execution of the current thread utill all threads in the thread group have called <a class="reference internal" href="#thread_sync" title="thread_sync"><span>thread_sync()</span></a>.</p>
<p>An exception will be raised if any threads in the thread group have exited.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>group</strong> &#8211; The thread group to synchronize with.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="thread_group_join">
void <tt class="descname">thread_group_join</tt><big>(</big><a class="reference internal" href="#thread_group_t" title="thread_group_t"><span>thread_group_t</span></a><em>&nbsp;group</em><big>)</big><a class="headerlink" href="#thread_group_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauses execution of the current thread until all threads in the thread group have exited.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>group</strong> &#8211; The thread group to join with.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="example-thread-usage">
<span id="sec-api-threads"></span><h3>Example thread usage<a class="headerlink" href="#example-thread-usage" title="Permalink to this headline">¶</a></h3>
<p>Example code that uses threads is shown below. First a channel is created.
A new thread is created that takes one end of the channel as an argument.
The new thread communciates over the channel. Finally the parent thread waits
for the new thread terminate and then frees the channel.</p>
<div class="highlight-none"><div class="highlight"><pre>void *input_thread(void *);

void thread_test() {
    thread_t t;
    unsigned int s[100];
    chanend_t c1, c2;
    chan_init(c1, c2);

    thread_create(&amp;t, &amp;input_thread, s, 100, &amp;c2);
    chan_out_int(c1, 123);
    thread_join(t);
    chan_exit(c1, c2);
}

void *input_thread(void *args) {
    int result;
    chanend_t c = *(chanend_t*)args;
    chan_in_int(c, result);
    return NULL;
}
</pre></div>
</div>
<p>Example code which uses thread groups is shown below. Here a thread group is
created and two threads are created in that thread group. When started the two
threads print strings using the printstr() function. The threads synchronize
using thread_sync() and thread_group_sync() to ensure the strings are printed
in the correct order.</p>
<div class="highlight-none"><div class="highlight"><pre>void *world_thread(void *args);
void *hello_thread(void *args);

void thread_group_test() {
    thread_group_t tgroup;
    thread_group_create(&amp;tgroup);

    unsigned int s1[100], s2[100];

    thread_create_in_group(&amp;world_thread, tgroup, s1, 100, NULL);
    thread_create_in_group(&amp;hello_thread, tgroup, s2, 100, NULL);
    thread_group_start(tgroup);
    thread_group_sync(tgroup);
    thread_group_sync(tgroup);
    printstr(&quot;!\n&quot;);
    thread_group_join(tgroup);
}

void *world_thread(void *args) {
    thread_sync();
    printstr(&quot;World&quot;);
    thread_sync();
    return NULL;
}

void *hello_thread(void *args) {
    printstr(&quot;Hello &quot;);
    thread_sync();
    thread_sync();
    return NULL;
}
</pre></div>
</div>
</div>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" id='d2'>
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Documentation</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">C XCore Resources</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#timers">Timers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api">API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#channels">Channels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ports">Ports</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#threads">Threads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-thread-usage">Example thread usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none;margin-bottom: 10px;">
  <h3>Search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>



    <div class="footer">
    </div>
  </body>
</html>



